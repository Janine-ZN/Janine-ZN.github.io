<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[一、问题如何对下面的数组进行去重： 1var arr = [1, 2, 2, 2, 3, 3, 3, 4, 5, 6]; 二、概念解析 indexOf(): 找到就返回下标，找不到就返回-1 filter(): 数组过滤方法，复制出原数组中符合条件的元素组成新数组返回。 123var subArr=arr.filter(function(elem,i,arr)&#123; return 判断条件&#125;) es5四种方式:方式一:1234567891011121314Array.prototype.unique_one = function () &#123; // 1. 定义临时数组 var temp = []; // 2. 遍历当前数组 for (var i = 0; i &lt; this.length; i++) &#123; // 3.如果当前数组的第i已经保存进了临时数组， // 那么跳过,否则把当前项push到临时数组里面 if (temp.indexOf(this[i]) === -1) &#123; temp.push(this[i]); &#125; &#125; return temp;&#125;;console.log("unique_one==&gt;", arr.unique_one()); // 方式二:1234567891011121314151617Array.prototype.unique_two = function () &#123; //1. hash为hash表，temp为临时数组 var hash = &#123;&#125;, temp = []; // 2.遍历当前数组 for (var i = 0; i &lt; this.length; i++) &#123; // 3. 如果hash表中没有当前项 if (!hash[this[i]]) &#123; // 4.存入hash表 hash[this[i]] = true; // 5.把当前数组的当前项 // push到临时数组里面 temp.push(this[i]); &#125; &#125; return temp;&#125;;console.log("unique_two==&gt;", arr.unique_two()); 123456789101112var arr_str = ["h", "e", "l", "l", "o"];// 方式三:Array.prototype.unique_three = function () &#123; var n = [this[0]]; for (var i = 1; i &lt; this.length; i++) &#123; if (this.indexOf(this[i]) === i) &#123; n.push(this[i]); &#125; &#125; return n;&#125;;console.log("unique_three==&gt;", arr_str.unique_three()); 123456789101112// 方式四:Array.prototype.unique_four = function () &#123; this.sort(); var re = [this[0]]; for (var i = 1; i &lt; this.length; i++) &#123; if (this[i] !== re[re.length - 1]) &#123; re.push(this[i]); &#125; &#125; return re;&#125;;console.log("unique_four==&gt;", arr.unique_four()); 1234567Array.prototype.unique_five = function () &#123; var res = this.filter((item, index) =&gt; &#123; return this.indexOf(item) === index; &#125;) return res;&#125;console.log("unique_five==&gt;", arr.unique_five()); 12345678910// es6实现方式:Array.prototype.unique = Array.prototype.unique || function () &#123; return [...new Set(this)];&#125;;/** 方法一：使用 ES6 语法中的 Set——数据集合 **/function fun1() &#123; var set = new Set(arr); return set;&#125;var result1 = fun1(); 1console.log(arr.unique);]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular6 breadcream 面包屑]]></title>
    <url>%2FAngular-6-breadcream-%E9%9D%A2%E5%8C%85%E5%B1%91%2F</url>
    <content type="text"><![CDATA[一、前期准备 面包屑组件（最好能封装成共享组件） 一些路由信息配置 Ant-Zorro 组件的环境配置（这里会套用里面的一些现成的组件库），版本: 7.0.1 二、Ant-Zorro 配置这里请参考官方网站 https://ng.ant.design/docs/getting-started/zh ，官方网站中，找到目录 快速上手 ，在里面有 自行构建，查看 自行构建 下的内容。 如果依然不能成功，可以浏览参考博主的另一个博客：里面讲了一些博主在配置 Ant-Zorro 的时候遇到的坑！ 三、自定义面包屑组件1. 创建一个自己的面包屑组件1ng g c breadcrumb --spec=false 2. 使用 Ant-Zorro 的面包屑组件12345&lt;nz-breadcrumb&gt; &lt;nz-breadcrumb-item&gt;Home&lt;/nz-breadcrumb-item&gt; &lt;nz-breadcrumb-item&gt;&lt;a&gt;Application List&lt;/a&gt;&lt;/nz-breadcrumb-item&gt; &lt;nz-breadcrumb-item&gt;An Application&lt;/nz-breadcrumb-item&gt;&lt;/nz-breadcrumb&gt; 将 Ant-Zorro 组件库中的面包屑组件，放到自己创建的面包屑组件的html文件中。将组件库中的面包屑做一点改动，将静态的面包屑改成动态的，使用 ngFor 循环自行加载，对应的路由信息。 123456&lt;nz-breadcrumb&gt; &lt;nz-breadcrumb-item&gt;首页&lt;/nz-breadcrumb-item&gt; &lt;nz-breadcrumb-item *ngFor="let breadcrumb of breadcrumbs"&gt; &lt;a [routerLink]="[breadcrumb.url, breadcrumb.params]"&gt;&#123;&#123; breadcrumb.label &#125;&#125;&lt;/a&gt; &lt;/nz-breadcrumb-item&gt;&lt;/nz-breadcrumb&gt; 3. 面包屑逻辑代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Router, ActivatedRoute, NavigationEnd, Params, PRIMARY_OUTLET &#125; from '@angular/router';import &#123; filter &#125; from 'rxjs/operators';interface IBreadcrumb &#123; label: string; params: Params; url: string;&#125;@Component(&#123; selector: 'app-breadcrumb', templateUrl: './breadcrumb.component.html', styleUrls: ['./breadcrumb.component.scss']&#125;)export class BreadcrumbComponent implements OnInit &#123; public breadcrumbs: IBreadcrumb[]; constructor( private activatedRoute: ActivatedRoute, private router: Router ) &#123; this.breadcrumbs = []; &#125; ngOnInit() &#123; // 订阅NavigationEnd事件 this.router.events.pipe(filter(event =&gt; event instanceof NavigationEnd)) .subscribe(event =&gt; &#123; // 设置面包屑 const root: ActivatedRoute = this.activatedRoute.root; console.log('=== janine.树的的根路由', root); this.breadcrumbs = this.getBreadcrumbs(root); &#125;); &#125; /** * 返回表示面包屑的IBreadcrumb对象的数组 */ private getBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: IBreadcrumb[] = []): IBreadcrumb[] &#123; const ROUTE_DATA_BREADCRUMB = 'breadcrumb'; // 得到子路由 const children: ActivatedRoute[] = route.children; console.log('=== janine.有多少子路由 ===', children); // 如果没有子路由返回 if (children.length === 0) &#123; console.log('=== janine.没有子路由是 ===', breadcrumbs); return breadcrumbs; &#125; // 遍历每个子元素 for (const child of children) &#123; // 验证主路由 if (child.outlet !== PRIMARY_OUTLET) &#123; continue; &#125; // 验证路由上指定的自定义数据属性'breadcrumb' if (!child.snapshot.data.hasOwnProperty(ROUTE_DATA_BREADCRUMB)) &#123; return this.getBreadcrumbs(child, url, breadcrumbs); &#125; // 获取路由的URL进行分割 const routeURL: string = child.snapshot.url.map(segment =&gt; segment.path).join('/'); // append route URL to URL 追加路由的url到url if (routeURL) &#123; console.log('=== janine.routeURL ===', routeURL); url += `/$&#123;routeURL&#125;`; &#125; // 添加面包屑 const breadcrumb: IBreadcrumb = &#123; label: child.snapshot.data[ROUTE_DATA_BREADCRUMB], params: child.snapshot.params, url: url &#125;; // 此处的 component 如果为 undefined，可能是因为懒加载，在查找时，没有找到 component 的值， // 所以当 component 为 undefined 的时候，就会又往数组里再追加一次，会重复 if (child.component) &#123; breadcrumbs.push(breadcrumb); &#125; console.log('=== janine.breadcrumbs === ', breadcrumb); // 递归 return this.getBreadcrumbs(child, url, breadcrumbs); &#125; &#125;&#125; 4. 知识点（1） filter1import &#123; filter &#125; from &apos;rxjs/operators&apos;; rxjs 的 filter() 方法，是 Angular6的，不是其他版本，如果版本不对，会出错! 对应的使用步骤如下： 12345678910ngOnInit() &#123; // 订阅NavigationEnd事件 this.router.events.pipe(filter(event =&gt; event instanceof NavigationEnd)) .subscribe(event =&gt; &#123; // 设置面包屑 const root: ActivatedRoute = this.activatedRoute.root; console.log(&apos;=== janine.树的的根路由&apos;, root); this.breadcrumbs = this.getBreadcrumbs(root); &#125;); &#125; （2）NavigationEnd, Params, PRIMARY_OUTLETRouter 和 ActivatedRoute 就不说了，这是 Angular 路由最常见的。讲一下 NavigationEnd, Params, PRIMARY_OUTLET。 NavigationEnd：表示当导航 成功结束 时（当从一个路径到另一个导航已经完成时）触发的事件。 Params：用来设置 IBreadcrumb 接口的 params 的类型为 Params。params 为非必需，其他两个为必需的。 12345interface IBreadcrumb &#123; label: string; params: Params; url: string;&#125; PRIMARY_OUTLET：一个常量 primary (3) 添加面包屑 代码中，有一段是将路由追加到数组中。这里会有一个关于懒加载的问题，代码注释里已经说明了。 如果有懒加载就得加个判读 child.component 是否 为 undefined ，只有不是 undefined 时才能向数组中追加，否则会重复(这里可以去掉判断，自己 debugger 一下，关注一下 component 值的变化，和数组追加后数组值的变化情况)。 如果没有懒加载，可以不对 breadcrumbs.push(breadcrumb); 做判断！ 1234567891011// 添加面包屑const breadcrumb: IBreadcrumb = &#123; label: child.snapshot.data[ROUTE_DATA_BREADCRUMB], params: child.snapshot.params, url: url&#125;;// 此处的 component 如果为 undefined，可能是因为懒加载，在查找时，没有找到 component 的值，// 所以当 component 为 undefined 的时候，就会又往数组里再追加一次，会重复if (child.component) &#123; breadcrumbs.push(breadcrumb);&#125; 5. 路由信息配置: data: { breadcrumb: ‘xxx’ }12345678910111213141516171819202122export const routes = [ &#123; // 路由为空时，自动重定向到/home path: &apos;&apos;, redirectTo: &apos;/home/basic&apos;, pathMatch: &apos;full&apos;, &#125;, &#123; path: &apos;home&apos;, component: HomeComponent, children: [ &#123; path: &apos;basic&apos;, loadChildren: &apos;./basic/basic.module#BasicModule&apos;, data: &#123; breadcrumb: &apos;基础&apos; &#125; &#125;, ... &#123; path: &apos;server&apos;, loadChildren: &apos;./server/server.module#ServerModule&apos;, data: &#123; breadcrumb: &apos;服务&apos; &#125; &#125; ] &#125;,]; 如果模块中，还有子路由，也是同样配置! 6. 效果图 附录源码地址：https://github.com/Janine-ZN/ng-basic （重点：breadcrumb.component.ts 和 routes.ts，还有一些模块中的路由配置） 参考的博客是针对 Angular2 的，而且不适用于路由懒加载，如果有路由懒加载的地方页面可能会出重复的路由。 博客参考地址：https://yfblog.cn/angular2-breadcrumb-using-router.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Angular6 路由跳转与传参]]></title>
    <url>%2FAngular-6-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E4%B8%8E%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[路由基础知识 名称 简介 Routes 路由配置，保存着哪个URL对应展示哪个组件，以及在哪个RouterOutlet中展示组件 RoutesOutlet 在html中标记路由内容呈现位置的占位符指令 Router 负责在运行时执行路由的对象，可以通过调用其navigate()和navigateUrl()方法来导航到指定的路由 RouterLink 在html中声明路由导航用的指令 ActivatedRoute 当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数等 有哪些方法可以进行路由跳转在前端中的路由一般分为 在页面通过a标签进行路由跳转，此时使用 routerLink 在逻辑代码中进行跳转，此时使用navigate/navigateByUrl 下面博主通过一个新闻列表和新闻详情进行演示： 一、routerLink ： 从列表页跳转到详情页，不传参 123&lt;!-- 列表详情页 --&gt;&lt;a routerLink="/home/news/news-detail"&gt; 跳转1&lt;/a&gt;&lt;a [routerLink]="['/home/news/news-detail']"&gt; 跳转2 &lt;/a&gt; 从列表页跳转到详情页，传参数 —— 单一参数: id 是需要传递的参数12// 在路由路径中配置参数的名称，此处带了一个叫 id 的参数变量&#123;path: 'news-detail/:id', component: NewsDetailComponent&#125; 1234&lt;!-- 3种方法: 设置参数变量的 值 --&gt;&lt;a routerLink="/home/news/news-detail/1"&gt; 跳转1&lt;/a&gt;&lt;a [routerLink]="['/home/news/news-detail/2']"&gt; 跳转2 &lt;/a&gt;&lt;a [routerLink]="['/home/news/news-detail',3]"&gt; 跳转3 &lt;/a&gt; 接受单一参数： （1）在 detail.ts文件中，接收参数，以下 2 种方法对上面三种方法的单个参数均可行 1234567891011// ActivatedRoute: 当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数等import &#123; ActivatedRoute &#125; from '@angular/router';...此处省略一万字...constructor(private route: ActivatedRoute) &#123; &#125;ngOnInit() &#123; // 1. 使用 ActivatedRoute 的 snapshot 快照的 paramMap 的 get(key) 方法 const id = this.route.snapshot.paramMap.get('id'); // 2. 使用 ActivatedRoute 的 snapshot 快照的 params 对象 const id = this.route.snapshot.params['id']; console.log('id==&gt;', id);&#125; （2）在 detail.ts文件中，接收参数，还有一种方法是订阅 subscribe，这种方法跟上面两种有点区别，要导入Params12345678910import &#123; ActivatedRoute, Params &#125; from '@angular/router';...此处省略一万字...constructor(private route: ActivatedRoute) &#123; &#125;ngOnInit() &#123; // 使用params的订阅 subscribe(不能使用 paramMap.subscribe) this.route.params.subscribe((params: Params) =&gt; &#123; const id = params['id']; console.log('id==&gt;', id); &#125;);&#125; 注意：123&lt;!-- 使用该方法获取不到id的值，id的值为undefined --&gt;const id = this.route.snapshot.queryParams[&apos;id&apos;];&lt;!-- 为什么呢？因为上面讲的参数不是使用查询参数queryParams进行设置的 --&gt; 在查询参数中，设置参数 （1）传递单一参数123&#123; // 路由路径：此处不设置参数 path: 'news-detail', component: NewsDetailComponent,&#125; 1234&lt;!-- 在html的a标签里直接设置查询参数 key:value，不在路由中配置 --&gt;&lt;a [routerLink]="['/home/news/news-detail']" [queryParams]="&#123;id: 4&#125;"&gt; 444 &lt;/a&gt; detail 的 ts 文件中，接收参数1234567// 1. 使用 ActivatedRoute 的 snapshot 快照的 queryParams 对象const id = this.route.snapshot.queryParams['id'];// 2. queryParams的订阅this.route.queryParams.subscribe((params: Params) =&gt; &#123; const id = params['id']; console.log('id==&gt;', id);&#125;); （2）传递多个参数123&#123; // 路由路径：此处不设置参数 path: 'news-detail', component: NewsDetailComponent,&#125; 12345678910&lt;!-- 在html的a标签里直接设置查询参数 key:value，此处设置多个参数 --&gt;&lt;a [routerLink]="['/home/news/news-detail']" [queryParams]="&#123;id: 4,title:'新闻详情'&#125;"&gt; 444 - 新闻详情&lt;/a&gt;&lt;!-- 以下不正确 --&gt;&lt;!--&lt;a [routerLink]="['/home/news/news-detail',&#123;queryParams:&#123;id: 4,title:'新闻详情'&#125;&#125;]"&gt; 444 - 新闻详情&lt;/a&gt;&lt;!--&lt;a routerLink=["/detail",&#123;queryParams:object&#125;]&gt;&lt;/a&gt;--&gt; detail 的 ts 文件中，接收参数12345678910// 1. 使用 ActivatedRoute 的 snapshot 快照的 queryParams 对象const id = this.route.snapshot.queryParams['id'];const id = this.route.snapshot.queryParams['title'];// 2. queryParams的订阅this.route.queryParams.subscribe((params: Params) =&gt; &#123; const id = params['id']; const title = params['title']; console.log('id==&gt;', id); console.log('title==&gt;', title);&#125;); 在路由配置中传递参数: 在路由配置中设置data，也可以进行传参 （1）传递单一参数1&lt;a routerLink="/home/news/news-detail"&gt; 跳转到详情页 &lt;/a&gt; 123456// 设置参数名称和参数值&#123; path: 'news-detail', component: NewsDetailComponent, data: &#123;title: '我是详情页1'&#125;&#125; 12// 获取参数this.title = this.routeInfo.snapshot.data['title']; （2）传递多个参数1&lt;a routerLink="/home/news/news-detail"&gt; 跳转到详情页 &lt;/a&gt; 12345678&#123; path: 'news-detail', component: NewsDetailComponent, data: &#123; title: '我是详情页1', subtitle: '我是详情页2' &#125;&#125; 123// 获取参数: 一个个获取this.title = this.routeInfo.snapshot.data['title'];this.title = this.routeInfo.snapshot.data['subtitle']; 二、navigate/navigateByUrl这里我们在list下的html文件中添加一个button，设置button的click事件，在click事件里做路由跳转 navigate （1）不传参123// list 文件&lt;!-- navigate 一定要加中括号 --&gt;this.router.navigate(['/home/news/news-detail']); （2）传单个参数12// 在路由路径中配置参数的名称，此处带了一个叫 id 的参数变量&#123;path: 'news-detail/:id', component: NewsDetailComponent&#125; 123456789// list 文件/* 同上面这三个相同&lt;a routerLink="/home/news/news-detail/1"&gt; 跳转1&lt;/a&gt;&lt;a [routerLink]="['/home/news/news-detail/2']"&gt; 跳转2 &lt;/a&gt;&lt;a [routerLink]="['/home/news/news-detail',3]"&gt; 跳转3 &lt;/a&gt;*/&lt;!-- 设置参数的值 --&gt;this.router.navigate(['/home/news/news-detail/1']);this.router.navigate(['/home/news/news-detail',1]); 注意：==接收参数的方式，查看 routerLink —&gt; 3. 接受单一参数，效果图也一样的== （3）传多个参数 123&#123; // 路由路径：此处不设置参数 path: 'news-detail', component: NewsDetailComponent,&#125; 12&lt;!-- 这里类似于上面的 查询参数 的单个参数传递--&gt;this.router.navigate(['/home/news/news-detail'], &#123; queryParams: &#123; 'id': '2' &#125; &#125;); 注意：==接收参数的方式，查看 routerLink —&gt; 5. 在查询参数中，设置参数，效果图也一样的== 123&lt;!-- 这里类似于上面的 查询参数 的多个参数传递--&gt;this.router.navigate(['/home/news/news-detail'], &#123; queryParams: &#123; 'id': '2' ,title:'详情页'&#125; &#125;); 注意：==同理，查看 routerLink —&gt; 5. 在查询参数中，设置参数，效果图也一样的== navigateByUrl 123// list 文件&lt;!-- navigateByUrl：上面讲的都没有这种方式 --&gt;this.router.navigateByUrl(&apos;/home/news/news-detail?id=&apos; + 1); 12345678&lt;!-- paramMap/params是针对参数（在路由路径里配置的参数：'news-detail/:id'） --&gt;// const id = this.route.snapshot.paramMap.get('id'); // null// const id = this.route.snapshot.params['id']; // undefined&lt;!-- 接收参数：queryParams 能接收，说明传过来的是一个查询参数 --&gt;this.activatedRoute.queryParams.subscribe(params =&gt; &#123; const id = params['id']; console.log('=== id ===&gt;', id);&#125;); 另外，下面navigateByUrl传单参和用法navigate一样1this.router.navigateByUrl('/home/news/news-detail/1'); 注意：无确凿证据，但是经过在代码中不段尝试，发现navigateByUrl不能设置多个参数，接受不到值，可能是获取值的方式不对吧，但是网上说navigateByUrl多参是可以的，获取的方式也很明显是 snapshot.queryParams 或者 queryParams.subscribe12this.router.navigateByUrl(['/home/news/news-detail'], &#123; queryParams: &#123; 'id': '2' ,title:'详情页'&#125; &#125;); 总结 在路由路径中配置参数”news-detail/:id”，获取方式就是params/paramMap/paramMap.subscribe 通过queryParams配置参数，获取方式就是snapshot.queryParams 或者 queryParams.subscribe 路由路径中配置的参数，浏览器地址栏上是/home/news/news-detail/1，queryParams配置的参数是/home/news/news-detail?id=1 源码地址：https://github.com/Janine-ZN/ng-basic （在routes–&gt;news模块下） 参考网址： https://blog.csdn.net/sky_beyond/article/details/78054771 https://www.kancloud.cn/jony_ii/angular/945657]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何有效的开站会]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E7%9A%84%E5%BC%80%E7%AB%99%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[前言讲站会就得先讲讲敏捷开发，下面是Scrum中文网对敏捷开发的说明： Scrum 是一个用于开发和维护复杂产品的框架 ，是一个增量的、迭代的 开发过程。在这个框架中，整个开发过程由若干个短的迭代周期 组成，一个短的迭代周期称为一个 Sprint（迭代），每个Sprint的建议长度是2到4周（互联网产品研发可以使用1周的Sprint）。 Scrum 使用产品 Backlog（一个按照商业价值排序的需求列表） 来管理产品的需求，列表条目的体现形式通常为用户故事。Scrum 团队总是先开发对客户具有较高价值的需求。 为了挑选出最高优先级的需求进行开发，Scrum 团队在Sprint 计划会议经过讨论、分析和估算，得到相应的任务列表，我们称它为Sprint Backlog。在每个Sprint（迭代）结束时，Scrum 团队将递交潜在可交付的产品增量。 每日站会是Scrum实践中最具代表性的一个形式。那么什么是站会呢？ 一、什么是站会 《Scrum指南》是这么说的：每日站会是一种限定在15分钟之内的活动，为的是让开发团队同步行动，并且为接下来的24小时建立计划。具体的做法是：审视上一次站会以来所做的工作，然后预测下一次开会前可以做的工作。为了降低复杂性，站会在每一天的相同时间以及相同地点召开。在会上，开发团队成员做如下说明： Whatdid I do yesterday that helped the Development Team meet the Sprint Goal? 昨天我做了什么来帮助开发团队达到Sprint目标？ Whatwill I do today to help the Development Team meet the Sprint Goal? 今天我将做些什么去帮助开发团队达到Sprint目标？ DoI see any impediment that prevents me or the Development Team from meeting theSprint Goal? 我是否看到了阻碍我或开发团队达到Sprint目标的困难？ 站会开的不好会有什么负面影响？ 员工会感觉压力较大，总感觉leader在监视自己 感觉leader是不是有点急功近利，感觉scrum master在刷存在感 感觉站会浪费时间，好不容易进入工作状态又被打断，太烦了 感觉站会就是在变相跟领导汇报工作，没什么意义 每次开会一小时，开完马上又到饭点了，一上午啥事没干就过去了 站会开的好会带来哪些积极效果？ 能够及时检视、同步和调整每日计划，及时发现阻碍团队进度的路障，及早暴露风险 能够基于团队目标，互通有无、快速反馈与协作，感知团队是否能够达成sprint的目标 可以了解到同事们在做什么，到什么样的进度了，间接的形成良性竞争 能够保证早上不会迟到，能很快进入工作状态 站会是生活和工作的分水岭，使员工能够快速的投入到工作，能够督促员工合理利用时间，有效完成工作任务。 一个自组织的健康的有效的团队该是什么样子？据说，有着非常明显的节奏： 每日站会(Daily Scrum)之前非常安静 每日站会之后会有一段活跃的讨论，到中餐前的时候就慢慢安静下来了 午饭之后会有另外一个阶段的活跃讨论，当下班前慢慢的安静下来 这就是一个自组织团队的脉冲。如果能够感受到这个节奏，则说明团队是很健康的，每日站会起到了很好的效果。那么我们要怎么开站会？ 二、怎么开站立会每日站会的时间 必须每天在同一时间、同一地点召开 最好的方式是在团队的可视化的任务板前面召开(例如：看板)。任务板上可以看到当前Sprint的燃尽图（Burn Down Chart）和Sprint中每个任务的状态。 在每日站会开始之前，每个团队成员需要在任务板上更新他负责的任务的状态。这样的好处是在开会的时候，每个人都可以看到当前的进展情况。 每日站会是Scrum团队每天的第一件事情，这样可以让每个人在每天一开始就清楚的了解他一天的安排。对于跨国界的团队，存在时间差的情况，可以根据实际情况做调整。 每日站会的纪律 会议时间最多不超过15分钟 所有的团队成员自觉按时到场，因为会议很短，按时召开按时结束是很重要的。对于迟到的人员要有一些让他们改进的措施，迟到会耽误大家时间。惩罚措施适当即可，最后由团队成员共同决定。 每日站会的形式 一定要站着开，每个人要精神集中，不能有懒散的表现。 每日站会的三个问题： 我昨天完成了什么任务？ 我今天打算做什么任务？ 我遇到了哪些障碍或困难？ 每日站会的的整体流程 同一时间只能有一个人发言，会上只说和上面三个问题相关的话题，任何跑题的讨论，需要被Scrum Master制止。一些的确需要讨论的问题，可以先记录下来，会后作为专题来讨论。 那么有些条条框框，为什么有的站会还是没什么效果呢？先看看每日站会和传统的项目会议有哪些不同的地方： Scrum master、leader或者其他任何人都可以来指派任务 团队成员不是向Scrum master或leader汇报工作，而是向其他的团队成员更新和同步信息。 团队成员不会在会上讨论或者解决问题，大家会把问题记录下来，会后找相关的人讨论或召开具体的讨论会议。 任何团队之外的人不得发言或干扰会议。 如果把每日站立会开成传统的会议，站会就失去了它原本的意义，那么它就不再是“站立会”！所以，开站立会有一些注意事项，请看下面的内容！ 注意事项 站会的时间和场地固定 禁止坐着开站会，一旦坐下时间就会变长 禁止开小会 禁止讨论项目中的具体细节 会上提出的障碍，会后立即开始解决它 及时更新任务看板，确保是最新状态 结束语站会没有开好就会有很多常见的误区，认为站会是为了给领导汇报工作，认为浪费时间，认为没什么意义。站会不是汇报工作，不是浪费时间，而是团队成员彼此承诺！stand-up，只是为了可以随时收工各自回去干活，严格遵循站会的规定和原则，工作会事半功倍(毕竟站会的规则是经过锤炼和项目考验的一些通用规则，如果站会开不出应有的效果，请多多学习！)。 友情链接 https://blog.csdn.net/poson/article/details/3153003https://www.techug.com/post/scrum-stand-meetting.htmlhttps://blog.csdn.net/happydeer/article/details/51288371https://www.zhihu.com/question/19655749http://www.uml.org.cn/SoftWareProcess/201004085.asp]]></content>
      <categories>
        <category>PMP</category>
      </categories>
      <tags>
        <tag>PMP</tag>
        <tag>站立会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白帽子讲Web安全]]></title>
    <url>%2F%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一篇 — 世界观安全，这里的安全世界观是作者的安全世界观，作者对安全的考虑和理解，起到了提纲挈领的作用。讲述了一些概念，理论和原则，比如什么是Web安全、什么是黑帽子和白帽子、安全的三要素是什么、如何做安全评估等。互联网安全与传统网络安全、信息安全技术是有所区别的，Web作为互联网的核心，是未来云计算和移动互联网的最佳载体，因此Web安全也是互联网公司安全业务中最重要的组成部分。 &nbsp;&nbsp;&nbsp;&nbsp;安全工程师的核心竞争力不在于他能拥有多少个0day，掌握多少种安全技术，而是在于他对安全理解的深度，一级由此引申的看待安全问题的角度和高度。 第一章 我的世界观Web 安全简史 Hacker —&gt; 获取用户态最高权限root/administrator，分为exploit和Script Kids(脚本小子) exploit：精通计算机技术，能自己挖掘漏洞并编写exploit，黑客们使用的漏洞利用代码，被称为exploit。 Script Kids的特点 只对攻击本身感兴趣，对计算机原理和各种编程技术的了解比较粗浅 只懂得编译别人的代码，自己没有动手能力 在现实世界里，会形成计算机犯罪、网络犯罪 中国黑客简史 启蒙时代 时间：20世纪90年代（受国外黑客技术的影响） 特点：崇尚分享(Share)、开放(Open)、免费(Free) 黄金时代 标志：中美黑客大战 特点：形成各种黑客组织，良莠不齐，开始以盈利为目的 黑暗时代 特点：优胜劣汰，走向没落，不在公布任何漏洞相关的技术细节 最为纯粹的黑客精神实质上已经死亡 黑客技术的发展历程 早期 攻击目标：系统软件居多，比如：网络、操作系统以及软件 原因：（1）Web技术发展不够成熟，并非主流，获取的权限比较低（2）攻击系统软件可以直接获得root权限 常用协议：SMTP、POP3、FTP、IPC 防火墙的出现：Cisco、华为等开始重视网络安全，改变了互联网安全的走向 里程碑事件：2003年冲击波蠕虫 Windows操作系统RPC服务（运行在455端口）的蠕虫，在很短的时间席卷全国，造成数百万台机器被感染，损失难以估量 网络运营商在骨干网络上屏蔽了135/445等端口的链接请求 整个互联网对于安全的重视达到了空前的高度 Web安全的兴起 Web 1.0 时代 服务器端动态脚本：一个可执行脚本（俗称webshell）上传到服务器上，从而获得权限 SQL 注入： 时间：1999年 Web安全史上的一个里程碑，通过 SQL 注入攻击 XSS（跨站脚本工具） 时间：2003年以后 又一个里程碑 与蠕虫事件有密切关系，在 OWASP 2007 TOP 10 威胁上XSS位居首榜 Web 2.0 兴起 催生了很多脚本 Python、Ruby、NodeJS 黑帽子，白帽子 白帽子 精通安全技术，但是工作在反黑客领域的专家 特点：只要能够找到系统的一个弱点，就可以达到入侵系统的目的 黑帽子 利用黑客技术造成破坏，甚至进行网络犯罪的群体 特点：必须找到系统所有弱点，不能有遗漏，才能保证系统不会出现问题 安全的本质&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安全问题的本质是 信任的问题，例如汽车站、火车站、高铁站等地方的安检（安全检查），分列出哪些是不安全的，哪些是安全的，进行过滤。又例如重要文件的保管，安全的前提，制作抽屉的工匠可信任，他没有私藏钥匙，但是信任如果被打破就不安全了，工匠私藏了一把钥匙。 &nbsp;&nbsp;&nbsp;&nbsp;安全是一个持续的过程。在安全的领域，不可能一劳永逸，也就是说“没有银弹”（银弹：在欧洲民间传说及19世纪以来哥特小说风潮的影响下，银色子弹往往被描绘成具有驱魔功效的武器，是针对狼人等超自然怪物的特效武器。后来也被比喻为具有极端有效性的解决方法，作为杀手锏、最强杀招、王牌等的代称） 安全三要素 机密性(Confidentiality) 要求保护数据内容不能泄露 常用手段：加密 案例：文件放在透明的玻璃盒子里，增加一个封面，遮掩文件内容 完整性(Integrity) 要求保护数据内容是完整、没有被篡改的 常用手段：数字签名 案例：康熙遗诏 可用性(Availability) 要求保护资源时“随需而得” 案例：停车场车位被占，这种攻击叫做拒绝服务攻击，简称DoS(Denial of Service) 拒绝服务攻击破坏的是安全的可用性 其他 可审计性、不可抵赖性 如何实施安全评估四个阶段：（层层递进，前后因果） 资产等级划分 所有工作的基础，这项工作能帮助苏我们明确目标是什么，要保护什么 互联网安全的核心问题，是数据安全的问题（用户产生业务，业务产生数据） 划分信任域和信任边界 威胁分析 可能造成危害的来源，称为威胁；可能出现损失的称为风险 威胁分析：把所有的威胁都找出来 使用头脑风暴法，尽可能地不遗漏威胁，头脑风暴可以确定攻击面。案例：《智取华山》，正路布重兵，忽略了小路/悬崖(漏洞) STRIDE 建模 风险分析 风险因素：Risk = Probability(可能性) * Damage Potential(破坏潜力) 案例：火山、地震带，日本火山、地震多发，风险可能性较大，但是破坏潜力一般不大；大陆中心，火山、地震不易发生，但是发生了会有很大的破坏力 DREAD 模型 确认解决方案 – 设计安全方案 安全评估的产出物，就是安全解决方案 解决方案要有针对性，这种针对性是由资产等级划分、威胁分析、风险分析等阶段的结果给出的 优秀安全方案的特点 能够有效解决问题 用户体验好 高性能 低耦合 易于扩展与升级 &nbsp;&nbsp;&nbsp;&nbsp;设计解决方案不难，难的是如何设计一个好的解决方案。案例一：杯子，评价一个杯子是否好用，除了能盛水之外，还有它的材质是否健康无毒，高温会不会熔化，低温会不会易碎。案例二：Windows Vista 的 UAC 功能，询问用户是否允许该行为 白帽子兵法 什么兵法？带兵打仗的方法。安全评估最后的产出物就是安全方案，但是在具体设计安全方案时有什么样的技巧和方法呢？ 白帽子兵法有四个原则：Secure By Default (安全缺省) 原则、纵深防御(Defense in Depth) 原则、数据与代码分离原则、不可预测(Unpredictable)原则 Secure By Default 原则 最基本、最重要的原则 一个方案设计得是否足够安全，与有没有应用这个原则有很大的关系 也可以归纳为白名单、黑名单的思想（安全问题的本质是信任问题，安全方案也是绝育信任来做的，白名单就是用户信任的，黑名单就是不被信任的不安全的） 另一层含义：最小权限原则 最小权限原则也是安全设计的基本原则之一，最小权限原则要求系统只授予主体必要的权限，而不要过度授权，这样能有效地减少系统、网络、应用、数据库出错的机会。 最小权限案例：Linux 需要 root 权限时，通过 sudo 完成。 在使用最小权限时，需要认真梳理业务所需要的权限，开发者并不会意识到业务授予用户的权限过高 纵深防御原则 重要指导思想 两层含义 要在各个不同分层面、不同方面实施安全方案，避免出现疏漏，不同安全方案之间需要相互配合，构成一个整体 一滴水经过十多层安全过滤，这种多层过滤体系，就是纵深防御，是有立体层次感的安全方案 并不是同一个安全方案做两遍或多遍，而是从不同层面、不同角度对系统做出整体的解决方案。 将风险分散到系统的各个层面，就入侵系统来说，我们需要考虑的可能有Web应用安全、OS系统安全、数据库安全、网络环境安全等。在这些不同层面设计的安全方案，将共同组成整个防御体系，这就是纵深防御的思想 要在正确的地方做正确的事情，即在解决根本问题的地方实施针对性的安全方案 （做正确的事，把事做正确。这是 PMP 中杨述讲到的。世间万事万物都是相通的，做正确的事，是选择一个正确的安全解决方案；把事做正确，是用正确的解决方案解决它能解决的问题上，针对性的解决问题） UTM，统一威胁管理(Uniform Threat Managment)，集成了很多主流安全产品的功能，如防护墙、VPN、反垃圾邮件、IDS、反病毒等，但是UTM并不是万能药，很多问题并不应该在网络层、网关处解决（这个产品就没什么针对性） XSS 防御技术（最近几年XSS防御思路逐渐成熟和统一） 数据与代码分离原则 重要的安全原则 广泛用于各种“注入”引发的安全问题 缓冲区溢出，程序在栈或堆中，将用户数据当做代码执行，混淆了代码与数据的边界，从而导致安全问题的发生 注入，XSS、SQL Injection、CRLF Injection、X-Path Injection，数据与代码分离原则可以设计注入问题的解决方案 不可预测原则 Secure By Default，是时刻要牢记的总则；纵深防御，是要更全面、更正确地看待问题；数据与代码分离，是从漏洞成因上看问题；不可预测性原则，是从克服攻击方法的角度看问题 不可预测性能有效地对抗基于篡改、伪造的攻击 不可预测性的实现往往需要用到加密算法、随机数算法、哈希算法，好好使用这条原则，在设计安全方案时往往会事半功倍]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>白帽子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装依赖]]></title>
    <url>%2Fdependency%2F</url>
    <content type="text"><![CDATA[一、安装依赖使用 npm install 进行依赖安装。1npm install 最简单的就是npm install，如果想单独安装具体的包，就在后面加上包名。1npm install 包名 此时安装的该包的版本号是最新的，可以在包名后添加指定的版本。1npm install 包名@版本号 安装开发时依赖12npm install 包名 --save-devnpm install 包名@版本号 --save-dev 安装运行时依赖，就是发布后还要依赖的东西12npm install 包名 --savenpm install 包名@版本号 --save 二、package.json在 package.json 文件中有两个重要的属性 dependencies 和 devDependencies dependencies 英文是指依赖的意思。 dependencies: 对应着 –save devDependencies: 对应着 –save-dev 通过 npm install 会将依赖的安装目录放到 node_modules 文件夹下，并且在 package.json中记录。 三、npm install 与 package.json之间的关系package.json 和 package-lock.json 的作用 每次 npm install xxx 会把内容记录到 package.json 文件中，下载的包都会发生变化，为了系统的稳定性考虑，每次执行完 npm install 之后会对应生成 package-lock 文件，该文件记录了上一次安装的具体的版本号。 什么是 package-lock.json 根据官方文档，package-lock.json 是生成的系统当前安装的库的具体来源和版本号，锁定版本。 npm install 发生了什么？ 当执行 npm install 的时候，node 会先从 package.json 文件中读取所有 dependencies/devDependencies 信息，然后根据 dependencies/devDependencies 中的信息与 node_modules 中的模块进行对比，在package.json 文件中没有读取到，就直接下载，node 是从 package.json 文件只读取模块名称，不读取版本信息，而是从 package-lock.json 文件中获取版本号，然后进行下载或者更新。 什么是 npm init –yes？ 当 package.json 与 package-lock.json 都不存在，执行 npm install 时，node 会重新生成 package-lock.json 文件，然后把 node_modules 中的模块信息全部记入 package-lock.json 文件，但不会生成 package.json 文件。但是，你可以通过 npm init –yes 来生成 package.json 文件 在 package.json 文件中手动输入包名和版本号会怎么样？ 在 dependencies/devDependencies 中手动输入包名和版本号，如：”vue-template-compiler”: “^2.6.10”，使用 npm install 安装即可。如果这里不清楚请回到”npm install 发生了什么？” 三、安装淘宝镜像 cnpm如果国内的网络不好，会导致一些依赖下载失败，可以使用国内的淘宝镜像，会方便很多1npm install -g cnpm --registry=https://registry.npm.taobao.org [参考地址] ：https://www.chenqaq.com/2017/12/29/dependencies-devDependencies/]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 相关命令]]></title>
    <url>%2FHexo%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 查看Hexo的版本号1hexo --version 2. 卸载&nbsp;&nbsp;&nbsp;&nbsp;有安装必然会有删除，安装使用 npm install -g hexo-cli 或 npm install -g hexo 。那么卸载使用什么呢？1234# 3.0.0版本及以上执行npm uninstall hexo-cli -g# 之前版本执行npm uninstall hexo -g 3. 如何安装特定版本的 Hexo ？&nbsp;&nbsp;&nbsp;&nbsp;如果你想安装特定版本，先卸载当前版本，以2.8.3为例，然后执行,下面这条语句： 1npm install hexo@2.8.3 -g 接下来就是，初始化并安装依赖和插件。 4.其他常见命令1234567hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令：12hexo s -g #生成并本地预览hexo d -g #生成并上传]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 本地部署]]></title>
    <url>%2FHexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[1. Hexo简介 1.1 什么是 Hexo？&nbsp;&nbsp;&nbsp;&nbsp;Hexo 是一个快速、简洁且高效的博客框架。[Hexo][2] 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2. 系统环境 &nbsp;&nbsp;&nbsp;&nbsp;这里博主使用的是win7 64位和Hexo 3.x。在搭建Hexo个人博客之前，需要安装 Node.js 和 git 。 点击下载： Node.js git 3. 安装Hexo&nbsp;&nbsp;&nbsp;&nbsp;安装好Git之后，打开 git-bash.exe （ 用来输入 shell 命令的，就是后面说的 Git Shell ） ，输入npm命令即可安装。 12345# 安装时，自动下载最新版本npm install -g hexo-cli# 或者使用下面的话npm install -g hexo# 两者有什么区别，博主也不是很清楚 4. Hexo初始化配置&nbsp;&nbsp;&nbsp;&nbsp;根据自己喜好建立目录（如E:\hexo），这个文件夹将来就作为存放代码的地方，名字可以随便取，进入 Git Shell 切换到该路径下E:\hexo执行以下指令: 12hexo init# 安装 Hexo 完成后，请执行下列命令，Hexo 将会在 `E:\hexo` 目录下新建所需要的文件。 初始化完成后， E:\hexo 目录下内容如下： 123456789.├── _config.yml├── package.json├── scaffolds├── scripts├── source| ├── _drafts| └── _posts└── themes 文件目录解释： _config.yml 文件是网站的配置文件，可以在其中配置网站的大部分参数。 package.json 文件是应用程序的信息。 source 是资源文件夹，是用来存放用户资源的地方。 themes 是主题文件夹，Hexo会根据主题来生成不同的静态页面。 scaffolds是模板件夹，当新建文章的时候，Hexo会根据模板来建立文件。 新版本的 source 文件夹下只有 _posts ,没有 _drafts ! 不要惊慌！！！ 5. 安装Hexo插件&nbsp;&nbsp;&nbsp;&nbsp;安装 Hexo 所需的各种插件插件，以后会一一介绍。 12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 6. 本地查看效果继续执行以下命令，成功后可登录localhost:4000查看效果。至此，hexo的本地部署已经完成。 1hexo server]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
